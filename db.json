{"Asset":{"cicrznknz8logroh":{"_id":"cicrznknz8logroh","source":"themes/writing/source/favicon.ico","mtime":1385045507000},"8kh6x52xehfbi7ja":{"_id":"8kh6x52xehfbi7ja","source":"themes/writing/source/fancybox/blank.gif","mtime":1385045507000},"weyhvj76d4wkfbiz":{"_id":"weyhvj76d4wkfbiz","source":"themes/writing/source/fancybox/fancybox_loading.gif","mtime":1385045507000},"t2rihqb5ueoss3m8":{"_id":"t2rihqb5ueoss3m8","source":"themes/writing/source/fancybox/fancybox_loading@2x.gif","mtime":1385045507000},"klm71ioak8msz6hk":{"_id":"klm71ioak8msz6hk","source":"themes/writing/source/fancybox/fancybox_overlay.png","mtime":1385045507000},"hgl0kzvfr9fn4xm2":{"_id":"hgl0kzvfr9fn4xm2","source":"themes/writing/source/fancybox/fancybox_sprite.png","mtime":1385045507000},"sw3e4cw1oqa1vpez":{"_id":"sw3e4cw1oqa1vpez","source":"themes/writing/source/fancybox/fancybox_sprite@2x.png","mtime":1385045507000},"ostu44heel36l4fk":{"_id":"ostu44heel36l4fk","source":"themes/writing/source/fancybox/jquery.fancybox.css","mtime":1385045507000},"2mh1gnt47hvy2egq":{"_id":"2mh1gnt47hvy2egq","source":"themes/writing/source/fancybox/jquery.fancybox.pack.js","mtime":1385045507000},"8alozkke4yw58kmg":{"_id":"8alozkke4yw58kmg","source":"themes/writing/source/js/gallery.js","mtime":1385045507000},"so2fnq3u6h1j2kns":{"_id":"so2fnq3u6h1j2kns","source":"themes/writing/source/js/jquery.imagesloaded.min.js","mtime":1385045507000},"yiqvrpwd39lbp6st":{"_id":"yiqvrpwd39lbp6st","source":"themes/writing/source/css/style.styl","mtime":1385045507000},"izswsnbfzb1ul281":{"_id":"izswsnbfzb1ul281","source":"themes/writing/source/css/font/fontawesome-webfont.eot","mtime":1385045507000},"xc61vh9n909ycc36":{"_id":"xc61vh9n909ycc36","source":"themes/writing/source/css/font/fontawesome-webfont.svg","mtime":1385045507000},"zwbt6gl02dfatf68":{"_id":"zwbt6gl02dfatf68","source":"themes/writing/source/css/font/fontawesome-webfont.ttf","mtime":1385045507000},"ut38rfa88onlk3jm":{"_id":"ut38rfa88onlk3jm","source":"themes/writing/source/css/font/fontawesome-webfont.woff","mtime":1385045507000},"87m0zdmj2pqnsako":{"_id":"87m0zdmj2pqnsako","source":"themes/writing/source/css/img/bg.jpg","mtime":1385045507000},"uzf3fujyocm7oox1":{"_id":"uzf3fujyocm7oox1","source":"themes/writing/source/css/img/logo.png","mtime":1385045507000},"qqnrraq8cyoggmce":{"_id":"qqnrraq8cyoggmce","source":"themes/writing/source/css/img/sprite-pagination.png","mtime":1385045507000},"nbql8c0lrkhyfxxu":{"_id":"nbql8c0lrkhyfxxu","source":"themes/writing/source/css/img/themes-newone-2.png","mtime":1385045507000},"ak45qj5kpthnqsj8":{"_id":"ak45qj5kpthnqsj8","source":"themes/writing/source/css/img/themes-newone.png","mtime":1385045507000},"40ip2p2i78ubzuwo":{"_id":"40ip2p2i78ubzuwo","source":"themes/writing/source/css/img/themes-writing-2.png","mtime":1385045507000},"5iwz7cvkk9zf98oi":{"_id":"5iwz7cvkk9zf98oi","source":"themes/writing/source/css/img/themes-writing.png","mtime":1385045507000},"5gyofloho4x5gljr":{"_id":"5gyofloho4x5gljr","source":"themes/writing/source/images/work/work-pdflabs.png","mtime":1384788622000},"nesfvdsu2qte6p4w":{"_id":"nesfvdsu2qte6p4w","source":"source/work-pdflabs.png","mtime":1384789112000},"c6rtpwaydkweudum":{"_id":"c6rtpwaydkweudum","source":"source/images/work-pdflabs.png","mtime":1384789181000}},"Cache":{"skjj78q6sqfqsuqh":{"_id":"skjj78q6sqfqsuqh","content":"title: 记：“摇滚吧，成都音乐节”\ndate: 2013-10-19 11:39:11\ntags:\n---\n\n# 前言\n\n    简单来说今年国庆期间最值得我高兴的两件事情，一件是跟老姐到音乐节摆地摊，另一件事情就是教会了一个大龄女青年骑车。 稍微得意一下。 话说程序员每天都过得CODE和BUG相依为命的生活，所以偶尔稍微有点不同总能让我感到兴奋。\n\n   老姐给我感觉是一直有一种裁缝的文艺气息，读的是新闻传媒偶尔喜欢卖弄小清新风格的文字，还没毕业有去学了服装设计， 后面实习结果又去了一家[@红秀](http://weibo.com/graziachina?sudaref=www.google.com.hk)的某时尚杂志社实习。 总的来说算得上是个文艺独立女青年，时常喜欢自己做点东西然后到上海各种群体活动（如音乐节）投机倒把的小勾当补贴日常开支。\n\n   ![](http://media.tumblr.com/8ca4f8185393da1cbddb8b3428d589ef/tumblr_inline_muwbunwAgE1sosno0.jpg)\n\n   文艺女青年登场\n\n# 照片墙\n   \n  先来几张卖的东西的照片，当然东西可基本上都是老姐手工做的，这样的好处就在于（呵呵）成本够低\n\n \n![](http://media.tumblr.com/47ee77a1bd0018f604130773d666aca8/tumblr_inline_muwaru3miP1sosno0.jpg)\n\n  各种手工装饰品\n\n![](http://media.tumblr.com/33332f42c530fa61ce42d870fb212266/tumblr_inline_muwbimgiIY1sosno0.jpg)\n\n各种手工装饰品（2）\n\n\n![](http://media.tumblr.com/a5bef1f85ad82d69e83c3d4b3547c252/tumblr_inline_muwbytF4Te1sosno0.jpg)\n\n\n下午的排练\n\n![](http://media.tumblr.com/d507059669f6c3e54aa67312c3c6972f/tumblr_inline_muwc8fYoXN1sosno0.jpg)\n\nDJ登场\n\n![](http://media.tumblr.com/53058c4990ecf7012b1bf687cce782a0/tumblr_inline_muwc91yaKr1sosno0.jpg)\n\n\n造型很牛叉的感觉\n\n![](http://media.tumblr.com/01774f505ad96d3790173b29fc423c93/tumblr_inline_muwd9f39321sosno0.jpg)\n\n夜幕，唐朝登场\n\n![](http://media.tumblr.com/a08a781dcd9ffe5e6c1ea8233511f542/tumblr_inline_muwdbwzu4J1sosno0.jpg)\n\n唐朝乐队，中国摇滚乐最著名乐队之一\n\n\n![](http://media.tumblr.com/2cd6d36bfd45df5ef9a37c6b3df14ac4/tumblr_inline_muwdllOgEZ1sosno0.jpg)\n\n邓紫棋（G.E.M.）\n\n\n![](http://media.tumblr.com/fafeff5196c0ed3e1321593d826f0a93/tumblr_inline_muwdruWtmD1sosno0.jpg)\n\n邓紫棋（G.E.M.）2\n\n\n![](http://media.tumblr.com/aafa148a5d8f7863f8618ae62e7dc41b/tumblr_inline_muwe1uj4p51sosno0.jpg)\n\n\n![](http://media.tumblr.com/7ff75dd723b568a2a01c8a2850882951/tumblr_inline_muwe63gXn51sosno0.jpg)\n\n痛苦的信仰乐队\n\n# 小结\n\n    程序猿的文艺生活\n","mtime":1385041945000,"source":"_posts/chengdu-rock.md"},"7j04iimc6ud3naco":{"_id":"7j04iimc6ud3naco","content":"title: CODE: 记最近刨的那些坑之Tornado Chat\ndate: 2013-10-19 17:00:40\ntags:\n---\n\n# Tornado Chat\n\n项目地址：[https://github.com/yunlzheng/chat](https://github.com/yunlzheng/chat)\n\n开发时间：1周\n\n# 开发目的\n\n话说程序猿总是喜欢抛各种各样的坑，然后再往里面跳。\n\n# 简介\n\n基于Tornado 和 html5 websocket技术的匿名在线聊天工具\n\n# 杂记\n\n## 前端杂记\n\n*  头像服务\n\n由于是提供的匿名聊天服务，所以系统并不会主动保存用户的信息，实际上这个项目上根本就没用到数据持久化的东西，所以头像的问题如何解决是一个简单但是不可忽视的问题，第一个想到的就是使用[gavatar全球头像服务](http://en.gravatar.com/)，python里面要对支持gavatar服务很简单\n\n\n    # import code for encoding urls and generating md5 hashes\n    import urllib, hashlib\n \n    # Set your variables here\n    email = \"someone@somewhere.com\"\n    default = \"http://www.example.com/default.jpg\"\n    size = 40\n \n    # construct the url\n    gravatar_url = \"http://www.gravatar.com/avatar/\" +hashlib.md5(email.lower()).hexdigest() + \"?\"\n    gravatar_url += urllib.urlencode({'d':default, 's':str(size)})\n\n\n这是这里只有两个东西，一个是当前用户的邮箱地址，一个是默认头像。 获取用户邮箱很简单，增加一个登陆流程，虽然是匿名聊天室，但是最起码你应该输入你的昵称吧，输入昵称的时候再顺便多输入一下你的邮箱地址也是很合情合理的吧。\n\n头像问题就解决了没？ 还没呢，这是你就会发现，如果当前登录的用户没有使用gavatar头像服务的话，所有人的头像都是一样的。。。。 这个就很尴尬了， 到时候说话时连谁和谁都不知道了。\n\n不知道有木有同学注意到过github的头像，它本身也是使用gavatar头像服务，所以就去捣鼓了一下github发现了一个很有意思的服务[identicons](https://github.com/blog/1586-identicons)，如果想知道它是干嘛的？[点我](https://identicons.github.com/jasonlong.png)，所以把上面的代码简单改进一下，修改一下default的值，就实现了我们的目的\n\n这就是所谓的不重复造轮子？ 完全是偷懒！\n\n*  消息通知\n\nchat里面消息通知主要从3个方面完成：未读消息数，chrome桌面通知，以及消息提示音；\n\n\n*  聊天表情Emoji\n\n Emoji是前端时间用tower.im时才知道有的那么一个东西，关于Emoji的发展背景也挺好玩的有兴趣的同学可以去Google一把，毕竟是聊天程序所以表情还是应该要有的在chat里面主要使用了前端的javascript库[emojify.js](https://github.com/hassankhan/emojify.js)。简单来说这个库的作用就是匹配当前页面里面有的emoji表情符号，并替换成实现定义好的emoji表情样式图片，用法很简单，导入项目所需的css和js文件。在页面载入时，做一次全局配置\n\n\n        emojify.setConfig({\n            emojify_tag_type: 'img',\n            emoticons_enabled: true,\n            people_enabled: true,\n            nature_enabled: true,\n            objects_enabled: true,\n            places_enabled: true,\n            symbols_enabled: true\n        });\n       \n   \n 然后当你觉得应该更新一下页面的时候，调用\n\n        emojify.run();\n\n\n就能将页面中的emoji表情符号替换成响应的图片或者是字符图 \n      \n\n\n*  背景图片\n\n作为一个只会写点css和javascript而又不懂设计的程序猿，在自己刨坑的时候能窃的就窃点，毕竟都是往坑里面填点东西而已，用过微信网页版的的小伙伴一看就知道，这前端，这样式不就是跟微信一样的呀？ 当然不一样，只能算是模仿，而且还是模仿的很拙劣的那一类，完全没有微信网页版UI的那种流畅感觉。tumblr是最近才开始使用的，之前都是在[oschina](http://my.oschina.net/fhck/blog)上写点东西，不过以前写东西和现在写东西的最大的不同就在于，以前老是把博客当做是个笔记之类的，所以老写些纯技术的东西，后面用了印象笔记，好的资料卡卡卡卡的就往印象笔记里面放，所以后面博客就写的少了。刚说了tumblr是最近才开始用的，优点就不说了，跟国内的博客服务相比一个感觉是文艺范的（毕竟是轻博客嘛，想到国内的点点就不免感叹几句）。\n\n言归正传，tubmlr的登录注册页面每次刷新都是些很漂亮的背景，所以我也一不做二不休，既然无耻了就再无耻一次吧。 \n\npython里面做HTML解析的库倒是很多，这里就不做一一列举，主要怕列举出来就有点装公知的感觉，实际上按最大范围值来计算本人做python到现在也就3个月的时间，连基础都还没学一遍就匆匆开始跟着[@__左弈__](http://weibo.com/xuwenbao)做项目了。\n\n这里主要使用BeautifulSoup来实现的对tumblr登录页面的解析，并获得那张精选的随机大图\n\n\n    import re\n    import tornado.gen\n    from tornado.httpclient import AsyncHTTPClient\n    from BeautifulSoup import BeautifulSoup\n    from chat.handler import BaseHandler\n\n\n    class TumblrHandler(BaseHandler):\n\n        @tornado.gen.coroutine\n        def get(self):\n            http_client = AsyncHTTPClient()\n            http_response = yield http_client.fetch(\"https://www.tumblr.com/\")\n            content = http_response.body\n            soup = BeautifulSoup(content)\n            img = soup.findAll('img')[0]\n            pattern=re.compile(r\"\"\"<img\\s.*?\\s?src\\s*=\\s*['|\"]?([^\\s'\"]+).*?>\"\"\",re.I)\n            m = pattern.findall(str(img))\n            self.write(m[0])\n\n由于项目使用tornado做的，所以在chat里面就实现了一个RequestHandler异步的去获取tumblr的背景图片，并无耻的被chat使用了（呵呵）\n\n## 后端杂记\n\n----------------------------------无耻的待更新-------------------------------------\n\n# 画廊\n\n![](https://raw.github.com/yunlzheng/chat/master/static/images/login.png)\n\n![](https://raw.github.com/yunlzheng/chat/master/static/images/chat.png)\n\n\n# 小结\n\n这算是我开始我python开发道路的第二个作业吧。 第一个作业同样是基于tornado开发的web程序在线图书分享[pdflabs](http://pdflabs.herokuapp.com/)以后有时间再总结","mtime":1385041945000,"source":"_posts/code-chat.md"},"r1e33cecnflp7l0m":{"_id":"r1e33cecnflp7l0m","content":"title: JavaScript学习笔记-原型继承\ndate: 2012-09-06 13:09:32\ntags:\n---\n\n```\n  原文最初写与我的[OSCHINA博客](http://my.oschina.net/fhck/blog/77091)\n```\n\nJavaScript基于原型的编程语言，本身并不包含内置的类实现。但是可以通过Javascript模拟出类\n\n# 类\n\nJavaScript中有构造函数和New运算符。构造函数用来实例对象和初始化属性。任何JavaScript函数都可以用作构造函数，构造函数必须使用new运算符作为前缀来创建新的实例\n\nJavaScript要模拟一个类可以直接使用函数function\n\n```\n\nvar Person = function(name){\n   this.name = name;\n}\n\n//实例化Person\nvar alice = new Person('alice');\nconsole.log(alice.name);\n```\n\n这里需要注意的this关键字， new运算符会改变函数的执行上下文，同时改变return的行为。当使用new运算符来调用构造函数时，执行上下文this从全局对象编程一个空的上下文，这个上下文代表新生成的实例。因此this指向当前创建的实例。\n\n所以一下代码执行会出现undefined\n\n```\nvar bob = Person('bob');\nconsole.log(bob.name);\n```\n\n# 原型    \n\nJavaScript本身是基于原型的编程语言，原型的作用:区别类和实例\n\n```\nvar Animal = function(){}\n\nAnimal.run = function(){\n    console.log('Animal run')\n}\n\nAnimal.prototype.breath = function(){\n   console.log('animal breath');\n}\n\nVar Dog = function(){}\n\n//Dog继承自Animal\nDog.prototype = new Animal();\n\nDog.prototype.wag = function(){\n   console.log('dog wag');\n}\n\nvar dog = new Dog();\ndog.wag();\ndog.breath();//继承的属性\n```\n\n输出：\n\n```\ndog wag\nanimal breath\n```\n\n那么通过类的prototype定义的方法或者属性就可以叫做所有实例的方法或属性，而其他的方法和属性就是类本身的方法和属性类比java类中的静态变量\n\n这里对下面一些东西的叫法约定一下\n\n通常按照个人习惯\n\n构造函数/匿名函数\n\n```\nvar Person = function(name){\n  this.name=name;\n}\n```\n\n函数/类\n\n```\nfunction Person(){}\n对象/实例\n\nvar person = { name:'zhangsan',sex:'male'}\n```\n\n\n# 原型继承继承是的什么？\n\n还是上面关于Animal和Dog的例子，我们做一些改造\n\n```\nvar  animal = {\n        breath:function(){console.log('animal breath!')},\n};\n\nvar Dog = function(){}\n\n//Dog继承自animal\nDog.prototype = animal;\n\nDog.prototype.wag = function(){\n   console.log('dog wag');\n}\n\nvar dog = new Dog();\ndog.wag();\ndog.breath();//继承的属性\n```\n\n结果和上面的一样\n\n在一个例子中我们使用 Dog.prototype = new Animail;   这个例子中我们使用的是Dog.prototype = animal\n\n区别在于第一个例子中的Animal是一个匿名类，通过调用new运算符调用其构造函数返回了一个animal实例，而第二个例子中animal本身就已经是一个实例/对象。这就是之前提到的new运算符的作用。\n\n所以一个类的如果要继承另一个类那么就需要继承那个类的实例而不是类本身（Function），当然我们可以试一下直接使用Dog.prototype=Animal，结果就是当调用dog.breath();时直接返回的是一个Function对象，无法达到共享属性的意义。\n\n\n原型对象就是一个“模板”，定义在原型上的属性被用来初始化一个新的对象。任何对象都可以作为一个对象的原型对象，以此来共享属性。\n\n   \n\n","mtime":1385041945000,"source":"_posts/javascript-property-learn.md"},"4ypydk03edlhifzy":{"_id":"4ypydk03edlhifzy","content":"title: Hello World\ndate: 2013-11-10 15:25:22\ntags: hello\n---\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/yunlzheng/utGW6/9/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>","mtime":1385041945000,"source":"_posts/hello-world.md"},"c0lu7hhljwgfp1gx":{"_id":"c0lu7hhljwgfp1gx","content":"title: Ubuntu Bind9泛域名解析配置\ndate: 2013-03-26 01:06:34\ntags:\n---\n\n# Bind9简介\n\n\nBIND (Berkeley Internet Name Domain)是Domain Name System (DNS) 协议的一个实现，提供了DNS主要功能的开放实现，包括\n\n域名服务器 (named)\nDNS解析库函数\nDNS服务器运行调试所用的工具\n是一款开放源码的DNS服务器软件，由美国加州大学Berkeley分校开发和维护的，\n\n按照ISC的调查报告，BIND是世界上使用最多最广泛的域名服务系统。不论你的邮件服务器，WEB服务器或者其他的services如何的安全可靠，DNS的故障会给你带来用户根本无法访问这些服务。\n\nBIND，也是我们常说的named，由于多数网络应用程序使用其功能，所以在很多BIND的弱点及时被发现。主要分为三个版本：\n\n## v4\n\n1998年多数UNIX捆绑的是BIND4，已经被多数厂商抛弃了，除了OpenBSD还在使用。OpenBSD核心人为BIND8过于复杂和不安全，所以继续使用BIND4。这样一来BIND8/9的很多优点都不包括在v4中。\n\n## v8\n\n就是如今使用最多最广的版本。\n\n## v9\n\n最新版本的BIND，全部重新写过，免费（但是由商业公司资助），也添加了许多新的功能（但是安全上也可能有更多的问题）。BIND9在2000年十月份推出，现在稳定版本是9.3.2。\n\n\n-----------------------------------------废话的分割线-----------------------------------------------\n\n-----------------------------------------主题的开始-------------------------------------------------\n\n# 安装bind9\n\n```\nsudo apt-get install bind9 bind9-doc dnsutils\n```\n\nbind9将默认安装在/etc/bind/目录下\n\n## rndc授权\n\n\n修改/etc/bind/named.conf.options,在未授权的情况下，将会出现\n\n错误信息：rndc: connect failed: 127.0.0.1#953: connection\n\n\n```\nsudo vim /etc/bind/named.conf.options\n```\n\n添加文件内容与/etc/bind/rndc.key相同\n例如rnfc.key的文件内容为：\n\n```\nkey \"rndc-key\" {\n        algorithm hmac-md5;\n        secret \"vfmD0+yvxhgW0wa8FQ54EQ==\";\n};\n```\n\n则在named.conf.options 中添加一下内容\n\n```\nkey \"rndc-key\" {\n        algorithm hmac-md5;\n        secret \"vfmD0+yvxhgW0wa8FQ54EQ==\";\n};\n\ncontrols {\n        inet 127.0.0.1 port 953\n                allow { 127.0.0.1; } keys { \"rndc-key\"; };\n};\n```\n\n到此为止Bind9的基本安装配置就算完成了。\n接下来是如何配置域名解析的问题\n\n## 添加本地区域文件\n\n创建文件 /etc/bind/zones.zheng\n\n```\nzone \"zheng.dev\"  { type master; file \"/etc/bind/db.zheng.dev\"; };\n```\n\n这里master表示DNS为主服务器\nfile则是只想该域的具体配置文件\n\n创建文件/etc/bind/db.zheng.dev\n\n添加一下内容\n\n```\n$TTL    86400\n@   IN  SOA localhost. root.localhost. (\n                  1     ; Serial\n             604800     ; Refresh\n              86400     ; Retry\n            2419200     ; Expire\n              86400 )   ; Negative Cache TTL\n;\n@   IN  NS  localhost.\n*.zheng.dev.    IN A    192.168.146.129\n```\n\n注意这里的 域名后缀也必须是与本地域配置文件中定义的zone相同。 *.zheng.dev. 表示匹配所有的以zheng.dev结尾的访问请求，这些请求都将会转发到192.168.146.129这台服务器。\n\n## 重启bind9 \n\n```\nsudo /etc/init.d/bind9 restart\n```\n\n这样一个最基本的基于bind9的泛域名配置即可完成\n\n-----------------------------------------再次废话的分割线---------------------------------------------\n\n感觉已经好久没写博客了。不负责任的讲是工作太多没时间，自己偷懒\n\n马上就到毕业设计了，毕业设计没完，老是觉得有道坎。老是有种只有毕业设计搞完，自己才可以毫无负担的凭爱好学习各种东西。悲催的是之前工作确实太忙了。还有差不多只有一个月的时间来准备毕业设计。 而我却基本才开始整理架构设计。\n\n\n\n\n\n\n","mtime":1385041945000,"source":"_posts/linux-bind9.md"},"44nfv0hbcgd05mcm":{"_id":"44nfv0hbcgd05mcm","content":"title: Tmux Linux会话管理神器\ndate: 2013-10-8 17:06:45\ntags:\n---\n\n## 邂逅Tmux\n\n   今天突然觉得每天背着自己的笔记本去公司上班是件活受罪不讨好的事情，于是还是决定在公司的Windows机器上重新弄一套开发环境，关于会话管理的东西之前有听领导介绍但却一直没有机会尝试一下，刚好今天又闲着没什么事情做，就尝试了一下Tmux\n\n## 初体验\n\n “高端大气上档次,低调奢华有内涵”，估计只有这话能形容一下使用的感受。会话管理那套东西就不多少说了，大家都懂。 给我感觉最牛B的还是它的多面板控制\n\n![](http://media.tumblr.com/a134acdee31402e4d91b147397e6ae21/tumblr_inline_mucqivJE881sosno0.png)\n\n## 安装\n \n* 环境Ubuntu 12.04\n\n```bash\nsudo apt-get install tmux\n```\n\n## 需要知道的概念\n\n* server    服务器。输入tmux命令时就开启了一个服务器。\n* session   会话。一个服务器可以包含多个会话。\n* window    窗口。一个会话可以包含多个窗口。\n* pane  面板。一个窗口可以包含多个面板。\n\n## 一些实用常用的命令\n\n### 基本命令\n\n* 开启一个新的会话\n\n```bash\ntmux\n```\n\n* 显示当前系统的所有会话\n\n```bash\ntmux ls\n```\n\n![](http://media.tumblr.com/ac9589bb921c65c0af88aae420012470/tumblr_inline_mucr4n5eWw1sosno0.png)\n\n\n* 重新链接到特定会话\n\n```bash\ntmux attach -t <会话编号>\n```\n\n![](http://media.tumblr.com/f3cfb99e5105aa5398a6f1f518d3072d/tumblr_inline_mucrc8Yakl1sosno0.png)\n\n### 控制台命令\n\n进入tmux后使用 ctrl+b 进入tmux控制台\n\n#### 系统操作\n\n* ？ 列出所有快捷键；按q返回\n* d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话\n* ctrl+z 挂起当前会话\n* : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器\n\n#### 面板操作\n\n* % 将当前面板平分为左右两块\n\n![](http://media.tumblr.com/b71f6d2f90c2a40b8d05cc1ca52e2f2d/tumblr_inline_mucrhc05gU1sosno0.png)\n\n* “ 将当前面板平分为上下两块\n\n![](http://media.tumblr.com/c527cce15b93d562f501b34574ac5765/tumblr_inline_mucre7xHJb1sosno0.png)\n\n* x 关闭当前面板\n\n![](http://media.tumblr.com/1d0eb920858a50863f2551b7adbdf859/tumblr_inline_mucribO2iM1sosno0.png)\n\n* ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小\n* o 在当前窗口中选择下一面板\n* 方向键 移动光标以选择面板\n* { / } 向前/后置换当前面板 \n\n## 更多的东西还需要你自己去试试！","mtime":1385041945000,"source":"_posts/linux-tmux.md"},"unrcevebt4jy9hnu":{"_id":"unrcevebt4jy9hnu","content":"title: Tomcat7 开启CGI，并配置awstats日志监控\ndate: 2012-10-8 17:42:38\ntags:\n---\n\n```\n  原文最初写与我的[OSCHINA博客](http://my.oschina.net/fhck/blog/85773)\n```\n\n# 搭建环境\n\nApache Tomcat 7.x\nJDK 1.6+\nPerl 5.2+\nUbuntu\n\n1，下载[Tomcat](http://www.fayea.com/apache-mirror/tomcat/tomcat-7/v7.0.32/bin/apache-tomcat-7.0.32.tar.gz)并解压到特定目录\n\n2,修改<Tomcat_HOME>\\conf\\web.xml配置文件，取消cgi servlet和对应的mapping注释\n\n```\n<servlet>\n <servlet-name>cgi</servlet-name>\n <servlet-class>org.apache.catalina.servlets.CGIServlet</servlet-class>\n <init-param>\n <param-name>debug</param-name>\n <param-value>0</param-value>\n </init-param>\n <init-param>\n <param-name>cgiPathPrefix</param-name>\n <param-value>WEB-INF/cgi</param-value>\n </init-param>\n <init-param>\n <param-name>passShellEnvironment</param-name>\n <param-value>true</param-value>\n </init-param>\n <load-on-startup>5</load-on-startup>\n</servlet>\n\n<servlet-mapping>\n <servlet-name>cgi</servlet-name>\n <url-pattern>/cgi-bin/*</url-pattern>\n</servlet-mapping>\n```\n\n3，修改<Tomcat_HOME>\\conf\\context.xml配置文件，在Context上添加privileged属性\n\n```\n<Context privileged=\"true\">\n<!--其他部分-->\n</Context>\n```\n\n4，安装Perl，window[点击下载](http://strawberry-perl.googlecode.com/files/strawberry-perl-5.16.1.1-32bit.msi)\n\n5，测试，在<Tomcat_HOME>\\webapps\\ROOT\\WEB-INF\\cgi\\下创建cgi脚本文件test1.cgi\n\n```\nprint \"Content-type: text/html\\n\\n\";\nprint \"Hello, world!\\n\"\n```\n\n6，启动Tomcat,并访问URL:[http:localhost:8080/cgi-bin/test1.cgi](http:localhost:8080/cgi-bin/test1.cgi)\n\n7,下载awstats日志分析工具,并解压到特定目录\n\n8，在<Tomcat_HOME>/webapps/下创建awstats目录以及相应的WEB-INF目录\n\n9，将<AWSTATS_HOME>/wwwroot/目录下css/,icon/,js/目录拷贝到<Tomcat_HOME>/webapps/awstats/目录下\n\n10,将<AWSTAS_HOME>/wwwroot/cgi-bin/下的所有文件拷贝到<TOMCAT_HOME>/webapps/awstats/WEB-INF/cgi目录下\n\n11，重命名<Tomcat_HOME>/webapps/awstats/cgi/awstats.model.conf 为awstats.localhost.conf\n\n\n```\n#对应日志文件所在位置\nLogFile=\"/home/test/server/apache-tomcat-7.0.29/logs/localhost_access_log.%yyyy-%mm-%dd.txt\"\n#站点域名\nSiteDomain=\"localhost\"\n#图标所在目录\nDirIcons=\"../icon\"\n#国际化所使用的语言，默认为\"auto\"\nLang=\"cn\"\n#国际化文件所在目录\nDirLang=\"./lang\"\n#在生成页面头部所要加入的HTML\nHTMLHeadSection=\"<div id=\"header\">Head Example</div>\"\n#在生成页面尾部索要加入的HTML\nHTMLEndSection=\"<div align='right'>@company</div>\"\n#生成页面所使用的样式表，awstas提供了默认的样式表，可通过该项目自定义awstats样式\nStyleSheet=\"../css/awstats_default.css\"\n```\n\n12,修改<TOMCAT_HOME>/conf/server.xml\n\n```\n<Service name=\"Catalina\"> \n  <Host name=\"localhost\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n      <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n               prefix=\"localhost_access_log.\" suffix=\".txt\"\n               pattern=\"combined\" fileDateFormat=\"yyyy-MM-dd\" resolveHosts=\"false\"/>\n</Host>\n</Service>\n```\n\n13，运行脚本 \n\n```\nawstats.pl -config=localhost -update\n```\n\n\n14,访问URL查看生成的日志页面：[http://localhost:8080/awstats/cgi-bin/awstats.pl?config=localhoost](http://localhost:8080/awstats/cgi-bin/awstats.pl?config=localhoost)\n\n\n\n\n\n","mtime":1385041945000,"source":"_posts/tomcat7-cgi-awstats.md"},"8p1v1b2qpiosm53u":{"_id":"8p1v1b2qpiosm53u","content":"title: about\ndate: 2013-11-14 15:15:09\n---","mtime":1385041945000,"source":"about/index.md"},"ft5hvef4lhmzpu9d":{"_id":"ft5hvef4lhmzpu9d","content":"title: 平时挖的那些坑\ndate: 2013-11-14 15:47:15\n---\n\n这里的都是一些自己平时用于练手的“坑”\n\n## [在线电子书分享](https://github.com/yunlzheng/PDFLabs)\n\n   pdflabs 基于tornado的在线电子书分享站点 [访问地址](http://pdflabs.herokuapp.com)\n\n## [Tornado chat](https://github.com/yunlzheng/chat)\n\n   基于websocket的多人在线匿名聊天程序\n","mtime":1385041945000,"source":"works/index.md"},"yzah597ln93611k0":{"_id":"yzah597ln93611k0","content":"title: 迁移到Hexo\ndate: 2013-11-19 00:12:44\ntags:\n---\n\n话说我本身并不是一个十分勤奋的人，博客也是偶尔热血沸腾的时候谢谢，想想以前在大学的时候第一次看到别人用wordpress时感到无比的神奇与羡慕，所以一直有一个自己的独立博客都是我十分向往的事情，但是碍于囊中羞涩，独立域名那些什么的都没考虑了，而且一直没发现一个又帅有苦的域名（冷）。\n\n之前写博客陆陆续续的在oschina上，tumblr上写过一段时间，oschina上唯一让我感觉比较爽的事情，如果你的文章稍微有点内容就很容易能上推荐页。所以偶尔也能带来一些其他的满足感，但是它的页面设计真心不敢苟同，最终坚持了几个月以后还是就荒废了。\n\n后面又发现了tumblr本来对我来说是一个足够理想和强大的博客落户地，它有非常牛B的自定义能力，而且文章编辑同时支持富文本和markdown,所以花了好一段时间去捣鼓tumblr的自定义。就像是找到了一个新奇的玩具一样。可以。。 唯有感叹墙内墙外。\n\n最近，大概一周前吧，在v2ex上论坛上有看到一篇关于静态博客搭建求助的帖子，大部分人都是提的jelly之类的，但是不大感冒。最后有人提到hexo,顺藤摸瓜算是对hexo有个初识，好吧。我感觉有时候我真的就像个孩子一样。 没次就像又发现的一个更好玩的玩具，又开始不断的捣鼓，看了hexo wiki里的几个主题，一个个都看了，都没什么感觉于是乎又自己捣鼓了一个新的主题，不过鉴于时间原因就直接在hexo默认主题上做了一些修改，并且让它跟本土化（china），在默认的disus的基础上添加了多说评论的支持。 重点来说自己感觉效果还不错吧，把默认主题里的 wiget什么的都是砍掉了，毕竟我只需要一个足够简单的能让我写东西的地方就行了。 唯一让我困扰的是hexo的图片处理问题， 虽说直接将图片放在source下是可以的，但是我怕将来会不会出现source下全是图片组织过于难看的尴尬境地，如果自己人工组织图片又显得太麻烦了。[微博图床](http://weibotuchuang.sinaapp.com)算是一个解决方案，但是也担心图片的丢失问题。这个问题算是唯一觉得hexo做的不太好的地方。\n\n\n最后，感觉还是应该鼓励一下自己一定要坚持更新博客，后面会陆陆续续把以前写的东西都搬到github上.\n","mtime":1385041945000,"source":"_posts/begin-hexo.md"},"k3nnaevjr8wgm2d5":{"_id":"k3nnaevjr8wgm2d5","content":"title: Ember.js(一):一个最基本的Ember应用程序\ndate: 2012-12-23 00:26:00\ntags:\n---\n\n\n```\n一个构建野心勃勃的web应用框架\n```\n\n# 一个最小的Ember应用程序\n\n一个最小可能性的Ember应用程序可以像下面描述的这样：\n\n```\nvar App = Ember.Application.create();\n\nApp.ApplicationView = Ember.View.extend({\n\n  templateName: 'application'\n\n});\n\nApp.ApplicationController = Ember.Controller.extend();\n\n\nApp.Router = Ember.Router.extend({\n\n  root: Ember.Route.extend({\n\n    index: Ember.Route.extend({\n\n      route: '/'\n\n    })\n\n  })\n\n});\n\nApp.initialize();\n```\n\n\n现在介绍该应用程序的每一部分\n\n\n```\nApp = Ember.Application.create();\n```\n\n这句话创建了一个新的Ember.Application的实例，这里完成了两件重要的事情\n\n\n\n* 为你的应用程序提供了一个统一的命名空间\n\n* 创建了一个对用户时间的监听器和事件代理控制器\n\n```\nApp.ApplicationView = Ember.View.extend({\n\n  templateName: 'application'\n\n});\n```\n\n在Ember中视图主要负责：\n\n\n\n* 决定应用程序的每一部分如何在HTML中进行渲染\n* 响应用户事件委托\n\n\n在视图之上我们只能通过改变视图模版来改变页面结构。\n\n你的应用程序必须包含一个ApplicationView的属性，这个类将会为你创建一个视图并插入插入到视图结构中并作为根视图。\n\n```\nApp.ApplicationController = Ember.Controller.extend(); \n```\n\n每一个视图都关联了一个上下文环境，这个上下文环境就是Handlebars模板引擎获取关联属性的对象，所以如果你的模版像下面这种结构：\n\n\n```\n{{name}}\n```\n\n并且这个模版的上下文环境包含一个name的属性，那么这个模版将为显示这个值，如果没有则什么都不会显示。\n\n\n一个单独的ApplicationController实例创建时将会自动关联到ApplicationView的上下文环境中。这里有一个简单并且明显的问题是。你的应用程序必须包含一个ApplicationController属性，否则应用程序的根视图将会无法关联上下文并且 Ember将会显示的抛出响应的异常信息\n\n \n```\nApp.Router = Ember.Router.extend({\n\n  root: Ember.Route.extend({\n\n    index: Ember.Route.extend({\n\n      route: '/'\n\n    })\n\n  })\n\n});\n```\n\n\nEmber的Router与你平时所使用的其它JavaScript类库的’router’标签的行为有着显著的区别，Ember的Router的子类有一个更加一般的目标StateManager。大多数浏览器的路由实现知识简单的模仿与服务器端技术。但是HTTP协议是一个特殊的无状态的协议栈，服务器端的路由技术缺少了一个重要的特定：如何将浏览器中的应用程序变成有状态的。\n\n状态是作为Ember应用程序的一个核心功能模块。当然属性和视图的双向绑定与自动更新时十分便利的，但是如果这就是Ember的全部的话，它只会成为严肃和健壮开发中的一小部分。\n\n \n```\nroot: Ember.Route.extend({\n\n    index: Ember.Route.extend({\n\n      route: '/'\n\n    })\n\n  })\n```\n\n你的router至少必须包含两个路由。首先，root作为所有子路由的容器。你可以把它作为一个路由的路径设置，而不是路由本身。Index的名字可以使任何值，它的关键是它必须包含一个值为’/’的route属性。当应用程序开始加载的时候Ember会自动搜索它的路由并获取一个与url想匹配的路由。如果你从url’/’进入应用程序，你的路由将会自动装换到该状态。\n\n\n```\nApp.initialize();\n```\n\n最后调用initialize,你的应用程序将会启动路由处理程序，并根据配置创建基本的结构，并且插入ApplicationView到页面中\n\n\n\n本文翻译至：http://trek.github.com/。为了避免由于蹩脚英语对大家造成误导，还是强烈建议学习原版文章，本文尽作为个人笔记\n\n\n","mtime":1385041945000,"source":"_posts/ember-begin.md"},"2yfgawyoa680gd4n":{"_id":"2yfgawyoa680gd4n","content":"title: 创建一个Ember应用程序\ndate: 2012-12-23 1:39:00\ntags:\n---\n\n\n添下来，添加所有贡献者的视图，并匹配控制器和模版的\nutlet到现在空的application模版当中\n\nOutlet帮助比较模版中将根据应用程序状态动态改变的部分。任何一个模版都可以包含任意多个outlets，这个特性使得你可以更加精细的控制视图的层次结构。\n\n接下来，添加所有贡献者的视图，并匹配控制器和模版。\n\n在路由中找到匹配路径为(”/”)的路由，并实现connectOutlets方法。该方法只有一个参数那就是你的应用程序的路由，在方法中获取ApplicationController 的实例并且使用connectOutlet 方法关联它的outlet：\n\n\n现在重新加载你的应用程序。你不会看见太多，但是这会让你发现浏览器中存在的一些错误。\n\n现在让我来缓解一下你内心中的恐惧。确实，这里突然增加了许多代码，并且显得有些古怪和复杂。当然你也可以使用更少的代码完成相同的任务通过使用Backbone或者Angular。但是Ember不是以完成这种复杂等级的应用作为目标，所以在刚开始时会显得愚蠢和冗长。\n\n现在倒过来分析一下我们的应用程序\n\n这里需要注意的一点事，当我们的应用程序完成initialize后，每一个器都会创建唯一的一个实例，由于你可能系统能从router中获取到这些实例，这些控制器实例豆浆作为router的以控制器的名字（注意头字母应该切换为消息如：ApplicationController对应的名字应该是applicationController）作为一个属性，你可以直接在router中获取到这些控制器实例。\n\n","mtime":1384794893000,"source":"_posts/ember-begin-2.md"},"od7e013lghm1fjiw":{"_id":"od7e013lghm1fjiw","content":"title: RabbitMQ之消息发布订阅与信息持久化技术\ndate: 2012-08-09 14:20:00\ntags:\n---\n\n\n# 信息发布与订阅\n\n\nRabbit的核心组件包含Queue(消息队列)和Exchanges两部分，Exchange的主要部分就是对信息进行路由，通过将消息队列绑定到Exchange上，则可以实现订阅形式的消息发布及Publish/Subscribe在这种模式下消息发布者只需要将信息发布到相应的Exchange中，而Exchange则自动将信息分发到不同的Queue当中。\n\n这种模式下Exchange充当的角色\n\n在命令行中可以使用\n\n```\nsudo rabbitmqctl list_exchanges\n```\n\n```\nsudo rabbitmqctl list_bindings\n```\n\n分别查看当前系统种存在的Exchange和Exchange上绑定的Queue信息。\n\n消息发布者EmitLog.java\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class EmitLog {\n\n\tprivate static final String  EXCHANGE_NAME=\"logs\";\n\t\n\tpublic static void main(String[] args) throws java.io.IOException{\n\t\t\n\t\t//创建链接工厂\n\t\tConnectionFactory factory = new ConnectionFactory();\n\t\tfactory.setHost(\"localhost\");\n\t\t//创建链接\n\t\tConnection connection = factory.newConnection();\n\t\t\n\t\t//创建信息管道\n\t\tChannel channel = connection.createChannel();\n\t\t\n\t\t//生命Exchange 非持久化\n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n\t\t\n\t\tString message = \"Message \"+Math.random();\n\t\t\n\t\t//第一个参数是对应的Exchange名称,如果为空则使用默认Exchange\n\t\tchannel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n\t\tSystem.out.println(\"[x] Sent '\"+message+\"'\");\n\t\t\n\t\t//关闭链接\n\t\tchannel.close();\n\t\tconnection.close();\n\t\t\n\t}\n\t\n}\n```\n\n消息消费者ReceiveLogs.java\n\n```\nimport java.io.IOException;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.ConsumerCancelledException;\nimport com.rabbitmq.client.QueueingConsumer;\nimport com.rabbitmq.client.ShutdownSignalException;\n\npublic class ReceiveLogs {\n\n\tprivate static final String EXCHANGE_NAME = \"logs\";\n\n\tpublic static void main(String[] args) throws IOException, ShutdownSignalException, ConsumerCancelledException, InterruptedException {\n\n\t\t//创建链接工厂\n\t\tConnectionFactory factory = new ConnectionFactory();\n\t\tfactory.setHost(\"localhost\");\n\t\t//创建链接\n\t\tConnection connection = factory.newConnection();\n\t\t\n\t\t//创建消息管道\n\t\tChannel channel = connection.createChannel();\n\n\t\t//声明Exchange\n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n\t\t\n\t\t//利用系统自动声明一个非持久化的消息队列，并返回唯一的队列名称\n\t\tString queueName = channel.queueDeclare().getQueue();\n\n\t\t//将消息队列绑定到Exchange\n\t\tchannel.queueBind(queueName, EXCHANGE_NAME, \"\");\n\n\t\tSystem.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n\n\t\t//声明一个消费者\n\t\tQueueingConsumer consumer = new QueueingConsumer(channel);\n\t\tchannel.basicConsume(queueName, true, consumer);\n\n\t\twhile (true) {\n\t\t\t\n\t\t\t//循环获取信息\n\t\t\tQueueingConsumer.Delivery delivery = consumer.nextDelivery();\n\t\t\tString message = new String(delivery.getBody());\n\t\t\tSystem.out.println(\" [x] Received '\" + message + \"'\");\n\t\t\t\n\t\t}\n\n\t}\n\n}\n```\n\n 运行时启动一个EmitLog.java多个ReceiveLogs.java则可以看到发布者每次发布信息，只要绑定到了相应Exchange的消费者都可以获取到信息。\n\n## RabbitMQ信息持久化技术\n\n上面的例子中我们实现了Publisher/Subscribe的消息分发方式，但是其中存在一些问题。比如当我们运行一个ReceiveLog都对应了一个特定的消息队列，可以利用list_queues进行查看，同时这些消息队列是帮到到名为logs的Exchange中，这是发布消息每个消费者都可以接收到，可以当关闭ReceiveLog程序后这些消息队列就都会自动销毁，因为他们是非持久化的。同样对于EmitLog程序也一样，每次关闭后之前生命的Exchange也将自动销毁。\n\n这就产生了一些问题。如果当ReceiveLog为运行时，此时就并没有一个消息队列是绑定到Exchange上的，在发布消息后再启动ReceiveLog程序是无法接受到之前发布的信息。这就是为什么要进行消息的持久化。\n\n通过持久化技术，我们可以生命一个持久化的Exchange，以及持久化的Queue这样，在把Queue绑定到Exchange后，即使没有消费者程序运行，信息依然能保存在Queue当中，当下次启动消费者程序时依然能获取到发布的所有信息。就好比当一个消费者程序在执行消息序列中的任务时，如果突然出现了异常那么重新启动后，依然能从上一次发生错误的位置继续运行，对于某些需要一个有序性和连续性的操作，这点显的尤为重要。\n\n下面还是给出一个例子，在持久化过程中，可以借助list_exchanges,list_bindings,list_queues来查看服务器中相关信息来帮组分析过程。\n\n\nPublisher.java\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.MessageProperties;\n\npublic class Publisher {\n\t\n\tprivate static final String  EXCHANGE_NAME=\"persi\";//定义Exchange名称\n\tprivate static final boolean durable = true;//消息队列持久化\n\t\n\tpublic static void main(String[] args) throws java.io.IOException {\n\n\t\tConnectionFactory factory = new ConnectionFactory();//创建链接工厂\n\t\tfactory.setHost(\"localhost\");\n\t\tConnection connection = factory.newConnection();//创建链接\n\t\tChannel channel = connection.createChannel();//创建信息通道\n                \n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\", durable);//创建交换机并生命持久化\n\n\t\tString message = \"Hello Wrold \"+Math.random();\n                //消息的持久化\n\t\tchannel.basicPublish(EXCHANGE_NAME, \"\", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n\t\t\n\t\tSystem.out.println(\"[x] Sent '\" + message + \"'\");\n\n\t\tchannel.close();\n\t\tconnection.close();\n\n\t}\n\t\n}\n```\n\nSubscriber.java\n\n```\npublic class Subscriber {\n\n\t\n\t//private static final String[] QUEUE_NAMES= {\"que_001\",\"que_002\",\"que_003\",\"que_004\",\"que_005\"};\n\tprivate static final String[] QUEUE_NAMES= {\"que_006\",\"que_007\",\"que_008\",\"que_009\",\"que_0010\"};\n\t\n\tpublic static void main(String[] args){\n\n\t\tfor(int i=0;i<QUEUE_NAMES.length;i++){\n\t\t\t\n\t\t\tSubscriberThead sub = new SubscriberThead(QUEUE_NAMES[i]);\n\t\t\tThread t = new Thread(sub);\n\t\t\tt.start();\n\t\t\t\n\t\t}\n\t\t\n\t}\n}\n```\n\n\nSubscriberThead.java\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.QueueingConsumer;\nimport com.rabbitmq.client.AMQP.Queue.DeclareOk;\n\npublic class SubscriberThead implements Runnable {\n\n\tprivate String queue_name = null;\n\tprivate static final String EXCHANGE_NAME = \"persi\";// 定义交换机名称\n\tprivate static final boolean durable = true;//消息队列持久化\n\t\n\tpublic SubscriberThead(String queue_name) {\n\t\t\n\t\tthis.queue_name = queue_name;\n\t\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\ttry{\n\t\t\n\t\tConnectionFactory factory = new ConnectionFactory();\n\t\tfactory.setHost(\"localhost\");\n\t\tConnection connection = factory.newConnection();\n\t\tChannel channel = connection.createChannel();\n\n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\", durable);\n\n\t\tDeclareOk ok = channel.queueDeclare(queue_name, durable, false,\n\t\t\t\tfalse, null);\n\t\tString queueName = ok.getQueue();\n\t\t\n\n\t\tchannel.queueBind(queueName, EXCHANGE_NAME, \"\");\n\n\t\tSystem.out.println(\" [\"+queue_name+\"] Waiting for messages. To exit press CTRL+C\");\n\n\t\tchannel.basicQos(1);//消息分发处理\n\t\tQueueingConsumer consumer = new QueueingConsumer(channel);\n\t\tchannel.basicConsume(queueName, false, consumer);\n\n\t\twhile (true) {\n\n\t\t\tThread.sleep(2000);\n\t\t\tQueueingConsumer.Delivery delivery = consumer.nextDelivery();\n\t\t\tString message = new String(delivery.getBody());\n\t\t\tSystem.out.println(\" [\"+queue_name+\"] Received '\" + message + \"'\");\n\t\t\tchannel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n\n\t\t}\n\t\t}catch(Exception e){\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\n\t}\n\n}\n```\n\n 通过持久化处理后rabbitMQ将保存Exchange信息以及Queue信息，甚至在rabbitMQ服务器关闭后信息依然能保存，这样就提供了消息传递的可靠性\n","mtime":1385041945000,"source":"_posts/rabbitmq-2.md"},"tek5xdguib9meuku":{"_id":"tek5xdguib9meuku","content":"title: Jenkins安装与配置\ndate: 2012-07-02 17:42:00\ntags:\n---\n\nJenkins安装与配置\n\n安装jenkins\n\n地址http://mirrors.jenkins-ci.org/war/选择合适的Jenkins版本下载\n\n将下载的jenkins.war包直接放到tomcat下，启动tomcat即可安装完成\n\n\n![](http://static.oschina.net/uploads/space/2012/0702/174713_juh7_553747.jpg)\n图表 1 Jenkins初始化界面\n\n配置Jenkins\n\n插件安装\n\n在jenkins界面中选择“系统管理——插件管理”进入jenkins插件管理界面。代码仓库我们机可能需要使用SVN也可能使用git作为代码仓库，这里安装git plugin\n\n安装完成插件后我们还需要去jenkins进行全局配置：“系统管理——系统设置”\n\nGit配置\n\n![](http://static.oschina.net/uploads/space/2012/0702/174728_BPlJ_553747.jpg)\n\n图表 2 Git配置\n\nName我们采用默认设置即可\n\nPath to Git executable是执行git的程序路径，根据git安装目录即可，这里注意目录分隔符使用”/”\n\nMaven配置\n\n\n![](http://static.oschina.net/uploads/space/2012/0702/174739_UNw4_553747.jpg)\n图表 3 Maven配置\n\nName：自己随便取一个名字即可\n\nMAVEN_HOME：就是你本机Maven的安装路径，根据实际情况配置即可\n\n全局MAVEN_OPTS：设置Maven运行时参数\n\nLocal Maven Repository：Maven的本地仓库默认即可\n\n新建Job\n\n在安装插件以及配置好Jenkins参数后即可新建Job测试配置效果，由于暂时未安装git服务器所以就直接使用github做测试，这里提供一个maven的java-web项目作为例子地址：https://github.com/yunlzheng/Hello-World\n\n点击”新Job”\n\n\n![](http://static.oschina.net/uploads/space/2012/0702/174759_DTik_553747.jpg)\n图表 4 新建Job 步骤1\n\n任务名字根据实际情况输入即可，这里我输入的是”TestJob”，选择构建一个maven2/3项目单击OK即可进入Job的详细配置页面\n\n\n![](http://static.oschina.net/uploads/space/2012/0702/174810_87jE_553747.jpg)\n源码管理\n\n即配置编译时的源码仓库\n\n![](http://static.oschina.net/uploads/space/2012/0702/174838_nfXw_553747.jpg)\n\n这里我们选择Git作为源码管理，在Repository URL中输入对应的git仓库地址即可https://github.com/yunlzheng/Hello-World.git\n\n构建触发器\nJenkins支持基于事件的构建代码机制，如按照时间周期构建，也可选择当检测到代码仓库发生变化时进行构建\n\n![](http://static.oschina.net/uploads/space/2012/0702/174854_XFJ9_553747.jpg)\n\n这里作为测试默认选择即可。\n\nPre Steps\n\n即构建前需要执行的工作这里不需要配置\n\nBuild\n\n由于测试时建立的是Maven2/3项目所以这里需要告诉Jenkins服务器构建maven项目所需的pom.xml文件所在的位置即项目项目根路径位置,根据项目实际情况设置即可\n\n![](http://static.oschina.net/uploads/space/2012/0702/174902_3qp1_553747.jpg)\n\n现在单击保存即可。保存后页面将跳转到Job页面点击立即构建即可\n\n![](http://static.oschina.net/uploads/space/2012/0702/174910_IBDC_553747.jpg)\n\n图表 5 Jenkins构建控制台输出\n","mtime":1385041945000,"source":"_posts/begin-jenkins.md"},"0qn7p4e53d0er34i":{"_id":"0qn7p4e53d0er34i","content":"title: jenkins插件开发\ndate: 2012-07-02 17:58:00\ntags:\n---\n\n# Jenkins插件开发简要介绍\n\n## 环境变量\n\n为了能开发插件，开发环境需安装Maven和JDK 6.0以上版本\n\n配置maven的settings.xml配置文件\n\n```\n<settings>\n  <pluginGroups>\n    <pluginGroup>org.jenkins-ci.tools</pluginGroup>\n  </pluginGroups>\n<profiles>\n<!-- Give access to Jenkins plugins -->\n    <profile>\n      <id>jenkins</id>\n      <activation>\n        <activeByDefault>true</activeByDefault> <!-- change this to false, if you don't like to have it on per default -->\n      </activation>\n      <repositories>\n        <repository>\n          <id>repo.jenkins-ci.org</id>\n          <url>http://repo.jenkins-ci.org/public/</url>\n        </repository>\n      </repositories>  \n      <pluginRepositories>\n        <pluginRepository>\n          <id>repo.jenkins-ci.org</id>\n          <url>http://repo.jenkins-ci.org/public/</url>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n</settings>\n```\n\n## 创建新的插件\n\n创建插件之前需运行以下Maven命令:\n\n```\nmvn -cpu hpi:create\n```\n\n该操作需要你输入一些参数，比如说groupid,artifactid。之后会创建一个新的插件模板便于开发者之后的开发工作。确保你可以使用一下命令：\n\n```\ncd newly-create-directory \nmvn package\n```\n\n## 设置Eclipse开发环境\n\n```\nmvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse\n```\n\n或者 使用m2eclipse插件在Eclipse打开即可\n\n## 插件目录结构\n\npom.xml：Maven的构建配置文件\n\nsrc/main/java：Java源文件目录\n\nsrc/main/resources：插件Jelly/Grovy视图\n\nsrc/main/webapps：插件的静态资源如images和html文件\n\n## 插件调试\n\n插件开发中在使用一下命令对插件进行调试\n\nWindows\n\n```\nset MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n\nmvn hpi:run\n```\n\nLinux\n\n```\n$ export MAVEN_OPTS=\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n\"\n$ mvn hpi:run\n```\n\n改变端口\n\n```\nmvn hpi:run -Djetty.port=8090\n```\n\n设置comtext path\n\n```\nmvn hpi:run -Dhpi.prefix=/jenkins\n```\n\n插件发布\n\n```\nmvn package\n```\n\n## 源码分析\n\n```\nimport hudson.Launcher;\nimport hudson.Extension;\nimport hudson.util.FormValidation;\nimport hudson.model.AbstractBuild;\nimport hudson.model.BuildListener;\nimport hudson.model.AbstractProject;\nimport hudson.tasks.Builder;\nimport hudson.tasks.BuildStepDescriptor;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.QueryParameter;\n\nimport javax.servlet.ServletException;\nimport java.io.IOException;\n\n/**\n * Sample {@link Builder}.\n *\n * <p>\n * When the user configures the project and enables this builder,\n * {@link DescriptorImpl#newInstance(StaplerRequest)} is invoked\n * and a new {@link HelloWorldBuilder} is created. The created\n * instance is persisted to the project configuration XML by using\n * XStream, so this allows you to use instance fields (like {@link #name})\n * to remember the configuration.\n *\n * <p>\n * When a build is performed, the {@link #perform(AbstractBuild, Launcher, BuildListener)}\n * method will be invoked. \n */\npublic class HelloWorldBuilder extends Builder {\n\n    private final String name;\n\n    // Fields in config.jelly must match the parameter names in the \"DataBoundConstructor\"\n    @DataBoundConstructor\n    public HelloWorldBuilder(String name) {\n        this.name = name;\n    }\n\n    /**\n     * We'll use this from the <tt>config.jelly</tt>.\n     */\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n        // This is where you 'build' the project.\n        // Since this is a dummy, we just say 'hello world' and call that a build.\n\n        // This also shows how you can consult the global configuration of the builder\n        if (getDescriptor().getUseFrench())\n            listener.getLogger().println(\"Bonjour, \"+name+\"!\");\n        else\n            listener.getLogger().println(\"Hello, \"+name+\"!\");\n        return true;\n    }\n\n    // Overridden for better type safety.\n    // If your plugin doesn't really define any property on Descriptor,\n    // you don't have to do this.\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl)super.getDescriptor();\n    }\n\n    /**\n     * Descriptor for {@link HelloWorldBuilder}. Used as a singleton.\n     * The class is marked as public so that it can be accessed from views.\n     *\n     * <p>\n     * See <tt>src/main/resources/hudson/plugins/hello_world/HelloWorldBuilder/*.jelly</tt>\n     * for the actual HTML fragment for the configuration screen.\n     */\n    @Extension // This indicates to Jenkins that this is an implementation of an extension point.\n    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {\n        /**\n         * To persist global configuration information,\n         * simply store it in a field and call save().\n         *\n         * <p>\n         * If you don't want fields to be persisted, use <tt>transient</tt>.\n         */\n        private boolean useFrench;\n\n        /**\n         * Performs on-the-fly validation of the form field 'name'.\n         *\n         * @param value\n         *      This parameter receives the value that the user has typed.\n         * @return\n         *      Indicates the outcome of the validation. This is sent to the browser.\n         */\n        public FormValidation doCheckName(@QueryParameter String value)\n                throws IOException, ServletException {\n            if (value.length() == 0)\n                return FormValidation.error(\"Please set a name\");\n            if (value.length() < 4)\n                return FormValidation.warning(\"Isn't the name too short?\");\n            return FormValidation.ok();\n        }\n\n        public boolean isApplicable(Class<? extends AbstractProject> aClass) {\n            // Indicates that this builder can be used with all kinds of project types \n            return true;\n        }\n\n        /**\n         * This human readable name is used in the configuration screen.\n         */\n        public String getDisplayName() {\n            return \"Say hello world\";\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {\n            // To persist global configuration information,\n            // set that to properties and call save().\n            useFrench = formData.getBoolean(\"useFrench\");\n            // ^Can also use req.bindJSON(this, formData);\n            //  (easier when there are many fields; need set* methods for this, like setUseFrench)\n            save();\n            return super.configure(req,formData);\n        }\n\n        /**\n         * This method returns true if the global configuration says we should speak French.\n         *\n         * The method name is bit awkward because global.jelly calls this method to determine\n         * the initial state of the checkbox by the naming convention.\n         */\n        public boolean getUseFrench() {\n            return useFrench;\n        }\n    }\n}\n```\n\n这里主要使用了jenkins的Builder作为扩展点，通过内部类DescripotorImpl添加@Extension声明，告诉系统该内部类是作为BuildStepDescriptor的扩展出现\n\n这里基本完成了扩展点的后台代码部分，但是扩展过程中还需要对前端页面进行扩张，这时就需要建立一个pcakage放置该扩展类对应的视图\n\n视图有三种:1,全局配置(global.jelly)2,Job配置(config.jeely),还有就是使用帮助(help-字段名).html\n\nglobal.jeely（对于插件需要使用的全局配置）\n\n```\n<j:jelly xmlns:j=\"jelly:core\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <!--\n    This Jelly script is used to produce the global configuration option.\n\n    Jenkins uses a set of tag libraries to provide uniformity in forms.\n    To determine where this tag is defined, first check the namespace URI,\n    and then look under $JENKINS/views/. For example, <f:section> is defined\n    in $JENKINS/views/lib/form/section.jelly.\n\n    It's also often useful to just check other similar scripts to see what\n    tags they use. Views are always organized according to its owner class,\n    so it should be straightforward to find them.\n  -->\n  <f:section title=\"Hello World Builder\">\n    <f:entry title=\"French\" field=\"useFrench\"\n      description=\"Check if we should say hello in French\">\n      <f:checkbox />\n    </f:entry>\n  </f:section>\n</j:jelly>\n```\n\n将插件部署到Jenkins后实际效果如下图（系统管理-系统设置）\n![](http://static.oschina.net/uploads/space/2012/0703/130915_9ows_553747.jpg)\n\n\nconfig.jeely（正对每个Job而言需要的配置信息）\n\n```\n<j:jelly xmlns:j=\"jelly:core\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <!--\n    This jelly script is used for per-project configuration.\n\n    See global.jelly for a general discussion about jelly script.\n  -->\n\n  <!--\n    Creates a text field that shows the value of the \"name\" property.\n    When submitted, it will be passed to the corresponding constructor parameter.\n  -->\n  <f:entry title=\"Name\" field=\"name\">\n    <f:textbox />\n  </f:entry>\n</j:jelly>\n``` \n\n部署到jenkins后的实际效果\n![](http://static.oschina.net/uploads/space/2012/0703/131122_ZUOx_553747.jpg)\n\n![](http://static.oschina.net/uploads/space/2012/0703/131152_4jbA_553747.jpg)\n\n\n \n\n\n这里细心的人可能已经看出来了，config.jelly中定义的字段实际就是扩展类中构造函数的参数，对于HelloWorldBuilder类而言自成了Builder父类，通过使用@DataBoundConstructor申明，当用户在界面填写配置信息点击保存后将自动初始化该类，同时会在对应的job的配置文件中保存相关信息本机是在.jenkins\\jobs\\TestJob目录下的config.xml文件中点击查看文件，在publishers节点下即可看见与该插件有关的信息\n\n```\n<prebuilders>\n    <org.wocloud.jenkins.manager.HelloWorldBuilder>\n      <name>Hello!!!!!!!!!!</name>\n    </org.wocloud.jenkins.manager.HelloWorldBuilder>\n  </prebuilders>\n```\n\n每一次修改配置并保存时都将修改该配置文件。\n在Job进行构建时，将会激活HelloWorldBuilder类的perform方法，而该方法中就是你插件真正开始完成工作的地方\n\n```\npublic boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) \n```\n\nlistener是此次构建工作的监听器\n\n通过该listener可以输出内容信息到前端jenkins页面\n\n使用build可以判断当前构建工作的结果\n\n \n\n \n","mtime":1385041945000,"source":"_posts/jenkins-plugin.md"},"wwb6icjt1y4svd2y":{"_id":"wwb6icjt1y4svd2y","content":"title: 初识Angularjs\ndate: 2013-11-19 21:45:35\ntags: javascript\n---\n\n![](http://angularjs.org/img/AngularJS-large.png)\n","mtime":1385041945000,"source":"_posts/myguest-about-angularjs.md"},"r415oix1rgmv02w7":{"_id":"r415oix1rgmv02w7","content":"title: 谈谈关于前端的MVC \ndate: 2013-11-21 21:58:17\ntags:\n---\n\n  记得最早说前端的MVC时，在大学里面教我们HTML老师是这样解释的， 在很早以前制作网页时充斥则诸如dreamware的网页制作（非开发）工具， 大部分的网页中都混杂了大量的嵌套在标签中的样式， css的片段，以及各种javascript脚本的片段。 所以在学校期间时的前端mvc就是html负责数据的展示，关于样式的控制全都交给css来处理，而页面中的逻辑处理，都交给javascript来完成。 这应该算是最早的关于前端的mvc的解释了。不过其实那个时候大部分web系统的逻辑处理还是交给服务器端程序来处理的。\n\n 再过了一段时间，SOA的概念慢慢盛行起来webservice,restful各种关于这些服务的开发框架如apache cxf慢慢入侵到曾经股如磐石的SSH解决方案当中，而随之而来的就是大量的逻辑代码都转移到了前端开发者的手中，记得那个是否领导是这样说的，用SOA的东西，我们可以只做一个后端服务，而客户端的形式可以随着需求不断的改变，不管是浏览器还是移动端都可以得到支持，当然这到现在也是算正确的。\n\n  而真正接触前端MVC是一年前看的那本叫做[《基于MVC的JavaScript Web富应用开发》](http://book.douban.com/subject/10733304/)的书，那时候才发现原来前端开发还可以这样结构化和层次化，当然那个时候也已经有了诸如Backbone和Ember的解决方案，而那时候由于公司也刚成立不久，研发工作还处在极其混乱的过程中，像我这样的年轻程序员和老一辈的程序员在一起工作，由于我自己的开发习惯更加注重前端和用户体验的东西所以开发系统时如上面说的喜欢把后端做的更接口化，而大量工作是放在前端来做的，而稍大的程序员则更喜欢诸如SSH式的解决方案，也更习惯把前端的逻辑控制放在JSP中，所以那时候有一段时间大家都在讨论如何让公司的研发工作更加统一一点，无论是以java为主的后端开发，还是js系的前端开发。 当然java企业级开发的解决方案特别多，无论是自己搭建还是找一套现成的解决方案都是比较容易的， 但是前端开发要找到一个合适的解决方案就不是那么容易的一件事情，可能每一个做web软件开发的人都会写那么点js代码，甚至完全不动javascript的人也能比较轻松的通过在网上copy实现一段js功能，但是由于大量逻辑工作转移到前端，而每个人的前端开发水平有参差不齐，所以每个人写出来的代码基本都只有他自己能看懂。 也就是说一个项目有10个人做前端开发，就有10种完全不同的编码方式， 可以预见随着系统越来越复杂和庞大的情况下，在不久的将来系统将变得越来越不可维护。当然这种情况都是发生在这样的初创公司里， 所以为了能解决这种问题那时候就开始对前端MVC框架有了一些接触，而那个时候是选择的ember.js作为解决方案。 不幸的是由于那个时候大部分做前端开发的都是即做后端也做前端的人， 而ember.js的开发方式又显的过于超前了一点，所以做了一段预研后，公司并没有使用这一解决方案， 而是稍微规范了前端开发的编码风格。\n\n  不过也是由于上面的原因，我开始重新审视过去所做的前端开发工作。\n\n* 代码臃肿\n* 缺乏可测试性\n* 协同开发能力弱\n* 可维护性极差\n* 由于jquery导致的大量事件绑定与回调\n* 业务逻辑与dom操作混杂....\n\n\n  所以一句话就感觉就像是一陀狗屎一样。\n\n\n  如果是ember.js算是对前端mvc的一次初识，那么Backbone.js算是第一次的实践，这两个前端MVC框架中Backbone感觉更轻量级一点，而且由于和jquery的搭配使用所以更容易上手一点。两个框架都可以通过浏览器的hash实现路由功能，也可以使用html5的pushstate来实现，不过需要后端配合。 两个框架都使用前端模板引擎来绑定视图和数据，不过在这方面感觉ember.js的能力更加牛B一点，它是双向的数据绑定，Backbone则需要自己实现对model的监听来更新视图。例如如下的这种形式的代码片段一样，完整代码[在这](https://github.com/yunlzheng/backbone-sample/blob/master/static/js/views/todos.js)\n\n```\n    initialize: function() {\n      this.listenTo(this.model, 'change', this.render);\n      this.listenTo(this.model, 'destroy', this.remove);        // NEW\n      this.listenTo(this.model, 'visible', this.toggleVisible); // NEW\n    }\n\n```\n\n在模板引擎方面两个框架分别使用了第三方的前端模板系统Handlebars和Underscor。其它的如model层两个框架都做了对浏览器本地存储和rest接口的适配。总的来说两个框架大部分东西都大同小异。\n\n这里我说说我觉得这两个前端MVC框架带来的一些好处， 代码层次更加清晰，协同开发性更好， 代码更加面向对象，当然可维护性也得到的很大的提高， 统一了每一个开发人员的编码风格等等， 但是却并没有解决所有的问题，如可测试性，依然不是很高， 部分代码中依然会混杂部分的dom操作。 不好的方面则在于在一些小的功能块显的有点大才小用了， 反而增加了一些复杂度， 所以说前端的MVC框架也并不是万能的解决方案， 更适合那些CRUD的系统实现同时后端应该是rest风格的接口设计。\n\n上面部分算是对之前学习Ember和Backbone的一些总结，在学习这两个框架的过程中，学到了许多新的是思想\n\n\n下面要说的主题，我们先来看一个例子:\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/yunlzheng/8N64v/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n这个例子实现了一个简单的购物车。 查看实际运行效果我们大概可以得出一下几个结论：\n\n* 模块化命名空间，依赖关系组织\n* 自动的数据双向绑定， 这该较少多少代码量\n* 业务逻辑完全不包含dom操作，意味着可测试行\n* 非侵入的事件绑定\n* UI区分与Controller的职责划分\n* 代码量更少了，因为只关注了业务逻辑\n\n这就是来自Google的前端JS框架Angular，当然今天写这边博客时，我也只算是对Angular有一个初步的认识， 但是当第一次看到它时，我就深深的被它这种简洁性吸引，同时它的核心特性如：MVC，模块化，依赖注入， 自动化双向数据绑定， 语义化标签等特性都显的那么个性鲜明。 用别人的一句话：编写web的应用的过程应该更像是创作，Angular就给了我这样的感觉。\n\n而且最重要的一种感觉就像是开篇文章所说的的那样老师在上课时教我们的那样，在“制作网页是”html负责数据展示，CSS控制页面的样式， 而javascript则实现页面的逻辑。 当然现在的网页制作有了一个更专业的名字叫前端开发。 从最初的mvc概念到后面的Ember和Backbone，再到Angular给我的感觉就像是一种 从简单到复杂再到简单的一个过程 \n\n这篇文章算是对我Angular深入学习的一份开篇\n","mtime":1385051341000,"source":"_posts/talk-about-mvc.md"}}}